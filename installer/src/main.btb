/*
    The installer user program.
    (also for develop)
*/

#import "Logger"
#import "OS"
#import "Net"
#import "Stream"

#import "libs/mbedtls-3.6.3/include/mbedtls.btb"

#import "./util.btb"

#macro VERSION "0.0.1"
#macro COMMIT_HASH ""
#macro SERVER_PORT 9723

fn print_version() {
    log("Wander Installer v",VERSION)
    if COMMIT_HASH.len != 0 {
        log("commit hash: ",COMMIT_HASH)
    }
}

struct Session {
    client: Client;
    net_lock: Semaphore; // this lock allows us to ask server for data and block until the callback is called then continue executing

    last_version: StringBuilder;

    bad_file: bool;

    get_file_data: char[];

    fn init() {
        net_lock.init(0, 1)
    }
}
global session: Session*;

fn main(argc: i32, argv: char**) -> i32 {
    /*
        First user experience
            - Download installer
            - Run installer (no flags)
                - It opens a terminal (for now)
                - 
    */
    /*
        Features
            Download game
                A game version has game files, manifest, signature.
                An installed game has static game version and permanent data.
                Permanent data is: user settings, world data
    */

    disable_safety := false
    run_game := false
    list_channels := false
    channel: StringBuilder;
    upload := false;
    upload_version: StringBuilder;
    upload_dir: StringBuilder;
    server_address: StringBuilder;
    // server_address.append("btb-lang.org")
    server_address.append("localhost")

    argi := 1
    while argi < argc {
        arg := Slice<char>{argv[argi], strlen(argv[argi])}
        argi++
        if arg == "-v" || arg == "--version" {
            print_version()
            return 0
        } else if arg == "-h" || arg == "--help" {
            log("The Wander Installer lets you securly download new versions.")
            log("You can also download beta versions and auto-update them while playing the game (hotreloading).")
            log("")
            log("If you want secure downloads you MUST ")
            log("")
            log("Flags:")
            log("  -v,--version        : Print version")
            log("  --unsafe            : Ignore hash and signature checks (still warns)")
            log("  --run               : Update and run game")
            log("  --list-channels     : List available game versions")
            log("  --channel <version> : Download a beta version or older game versions")
            log()
            log("Dev flags:")
            log("  --upload <version> <game_files_dir> : Upload release or beta game version.\n       Requires 'dev.token' for authentication to content server.")
            log("  --ip <server_ip>[:port] : Connect to a different content server (btb-lang.org is default)")
            return 0
        } else if arg == "--unsafe" {
            disable_safety = true
        } else if arg == "--run" {
            run_game = true
        } else if arg == "--list-channels" {
            list_channels = true
        } else if arg == "--channel" {
            if argi >= argc {
                log("Missing argument after ", arg)
                return 1
            }
            channel.clear()
            channel.append(argv[argi])
            argi++
        } else if arg == "--ip" {
            if argi >= argc {
                log("Missing argument after ", arg)
                return 1
            }
            server_address.clear()
            server_address.append(argv[argi])
            argi++
        } else if arg == "--upload" {
            upload = true
            if argi >= argc {
                log("Missing argument after ", arg)
                return 1
            }
            upload_version.clear()
            upload_version.append(argv[argi])
            argi++
            if argi >= argc {
                log("Missing argument after ", arg)
                return 1
            }
            upload_dir.clear()
            upload_dir.append(argv[argi])
            argi++
        } else {
            log("Unknown argument ", arg)
            return 1
        }
    }

    session = Allocate(sizeof(Session))
    construct(session)

    // Separate server IP and port
    port := SERVER_PORT
    {
        at := find(":",server_address, true)
        if at != -1 {
            head := at+1
            valid: bool
            port = parse_i64(&head, server_address, &valid)
            if !valid {
                log(LOG_RED,"ERROR: '",substring(server_address, at), "' is not a valid number.")
                return 1
            }
            if port < 0 || port > 0xFFFF {
                log(LOG_RED,"ERROR: Port ",substring(server_address, at), " must be within 0 - 65535.")
                return 1
            }
            server_address.len = at
        }
    }

    session.client.set_callback(handle_event, null)
    res := session.client.start(server_address, port, protocol = NET_TCP | NET_PROTO_MESSAGE)
    if res != NET_SUCCESS {
        log(LOG_RED,"ERROR: ",LOG_NO_COLOR,"Could not connect to content server at ",server_address, ":",port)
        return 1
    }

    log("Retrieving latest version...")
    latest_version := RetrieveLatestGameVersion()

    log("Latest version: ", latest_version)


    // Ask user, do you want to install?
    log("Do you want to install ", latest_version,"?")
    log("Yes")

    log() // extra spacing to separate downloading output

    // No flags -> install latest game version
    // Ask server for latest version

    DownloadGameVersion(latest_version)

    return 0
}

// Blocking
fn RetrieveLatestGameVersion() -> StringBuilder {
    msg: ByteStream
    defer msg.cleanup()
    msg.write<i32>(MSG_LATEST_VERSION)

    data: u8[];
    msg.finalize(&data)

    session.client.send(data)

    session.net_lock.wait()

    return session.last_version
}

fn DownloadGameVersion(version: char[]) {
    res: i32;
    warnings := 0;

    // TODO: Temporary
    #macro INSTALLER_DIR "sandbox/installer"

    version_root: StringBuilder
    defer version_root.cleanup()
    version_root.append(INSTALLER_DIR)
    version_root.append("/")
    version_root.append(version)
    version_root.append("/")

    log("Downloading manifest.txt")
    signature_path: StringBuilder
    defer signature_path.cleanup()
    signature_path.append(version_root)
    signature_path.append("manifest.sig")
    res = DownloadFile(version, "manifest.sig", signature_path)
    if !res {
        return
    }

    manifest_path: StringBuilder
    defer manifest_path.cleanup()
    manifest_path.append(version_root)
    manifest_path.append("manifest.txt")
    res = DownloadFile(version, "manifest.txt", manifest_path)
    if !res {
        return
    }
    // Download manifest.txt last so we have the file data cached in memory (in session.get_file_data)

    verified := VerifySignature(signature_path, manifest_path)
    if !verified {
        log(LOG_YELLOW,"WARNING:",LOG_NO_COLOR," manifest.txt has been tampered with!\n  (or the server mixed up the manifests?)")
        warnings++
        // Keep going anyway or no?
    }

    log("Downloading game files...")

    // Replace carriage return
    for @ptr c : session.get_file_data
        if *c == '\r';
            *c = ' '

    struct ManifestFile {
        fn cleanup() {
            file.cleanup()
            hash.cleanup()
        }
        file: StringBuilder;
        hash: StringBuilder;
    }
    files: Array<ManifestFile>
    defer files.cleanup()

    lines := split("\n", session.get_file_data)
    defer lines.cleanup()
    for lines {
        head := 0
        parse_space(&head, *it)
        path := parse_non_space(&head, *it)
        parse_space(&head, *it)
        hash := parse_non_space(&head, *it)

        if hash.len == 0 // Skip empty lines (also skips lines with just a value or key, not a pair)
            continue

        if path == "version"
            continue
        if path == "date"
            continue

        // log(" ", nr, " ", path, " -> ", hash)

        if hash.len != 64 {
            log(LOG_RED, "ERROR:", LOG_NO_COLOR, " Hash length is ", hash.len," but should be 64 for SHA-256")
            return
        }

        f: ManifestFile
        f.file.append(path)
        f.hash.append(hash)
        files.add(f)
    }
    
    bad_file_count := 0

    path: StringBuilder
    defer path.cleanup()

    
    temp_hash: u8[32]; // SHA-256 output is 32 bytes
    for mf : files {
        path.clear()
        path.append(version_root)
        path.append(mf.file)
        // log("Downloading ", mf.file)
        res = DownloadFile(version, mf.file, path)
        if !res {
            bad_file_count++
            continue
        }

        file_data := session.get_file_data
        
        res = mbedtls_sha256(cast<void*>file_data.ptr, file_data.len, temp_hash.ptr, 0); // 0 = SHA-256 (224 otherwise?)
        if res != 0 {
            log("FAIL ",res," mbedtls_sha256 ", path)
            continue
        }

        // @OPTIMIZE compare per 64-bit integer instead of per character
        diff := false
        for 0..32 {
            a: i32 = mf.hash.ptr[2*nr]
            b: i32 = mf.hash.ptr[2*nr+1]
            if a >= cast<i32>'0' && a <= cast<i32>'9' {
                a = a - '0'
            } else if (a|32) >= cast<i32>'a' && (a|32) <= cast<i32>'f' {
                a = (a|32) - 'a' + 10
            } else {
                log(LOG_YELLOW,"WARNING: ",LOG_NO_COLOR,"Hash for ",mf.file," contain non-hexidecimal characters!")
                warnings++
                return 
            }
            if b >= cast<i32>'0' && b <= cast<i32>'9' {
                b = b - '0'
            } else if (b|32) >= cast<i32>'a' && (b|32) <= cast<i32>'f' {
                b = (b|32) - 'a' + 10
            } else {
                log(LOG_YELLOW,"WARNING: ",LOG_NO_COLOR,"Hash for ",mf.file," contain non-hexidecimal characters!")
                warnings++
                return 
            }
            if temp_hash[nr] != (a << 4) | (b) {
                diff = true
                break
            }
        }

        if diff {
            log(LOG_YELLOW, "WARNING: ",LOG_NO_COLOR, mf.file, " has been tampered with!\n  (or server sent the wrong file?)")
            warnings++
        }
    }
    
    if bad_file_count > 0 {
        log(LOG_RED, "ERROR: ",LOG_NO_COLOR,"Manifest file is corrupt. Content server is missing ", bad_file_count, " file(s).")
        return;
    }
    if warnings > 0 {
        log(LOG_YELLOW,warnings," warning(s)",LOG_NO_COLOR)
    } else {
        log("Succesfully downloaded ", files.len, " files for ", version)
    }
}

fn VerifySignature(signature_path: char[], manifest_path: char[]) -> bool {
    res: i32;

    signature_data := ReadWholeFile(signature_path)
    if !signature_data.ptr {
        log("Could not read ", signature_path)
        return false
    }

    manifest_data := ReadWholeFile(manifest_path)
    if !manifest_data.ptr {
        log("Could not read ", manifest_path)
        return false
    }
    
    hash: u8[32]; // SHA-256 output is 32 bytes
    res = mbedtls_sha256(cast<void*>manifest_data.ptr, manifest_data.len, hash.ptr, 0); // 0 = SHA-256 (224 otherwise?)
    if(res != 0) {
        log("FAIL mbedtls_sha256 ", res);
        return false;
    }

    ctx: mbedtls_pk_context;
    mbedtls_pk_init(&ctx);

    res = mbedtls_pk_parse_public_key(&ctx, cast<void*>public_key.ptr, public_key.len + 1); // +1 to include null terminator
    if(res != 0) {
        log("FAIL mbedtls_pk_parse_public_key ", res);
        return false;
    }
    res = mbedtls_pk_verify(&ctx, MBEDTLS_MD_SHA256, hash.ptr, 32, signature_data.ptr, signature_data.len);
    if res == MBEDTLS_ERR_RSA_VERIFY_FAILED {
        // Verify failing is somewhat expected behaviour.
        // We don't print anything here.
        return false
    }
    if(res != 0) {
        log("FAIL mbedtls_pk_verify ",res);
        return false;
    }

    // Verify success!
    return true;
}

fn DownloadFile(version: char[], file: char[], out_path: char[]) -> bool {
    msg: ByteStream
    defer msg.cleanup()
    msg.write<i32>(MSG_GET_FILE)
    msg.write_string8(version)
    msg.write_string8(file)

    data: u8[];
    msg.finalize(&data)

    session.client.send(data)

    session.net_lock.wait()

    if session.bad_file {
        session.bad_file = false
        return false
    }

    at := find("/", out_path, true)
    dir := substring(out_path, 0, at)
    DirectoryCreate(dir)

    f := FileOpen(out_path, FILE_CLEAR_AND_WRITE)
    if !f {
        log("Could not write to ", out_path)
    }
    defer FileClose(f)

    FileWrite(f, session.get_file_data.ptr, session.get_file_data.len)

    return true
}

fn handle_event(e: NetEvent*, user_data: void*) {
    if e.type != EVENT_RECEIVE
        return;

    // log(e)

    stream: ByteStream
    defer stream.cleanup()
    stream.write(e.bytes.ptr, e.bytes.len)

    head := 0
    kind: MessageType
    stream.read<i32>(&head, cast<i32*>&kind)

    switch kind {
        case MSG_RESPONSE_LATEST_VERSION:
            stream.read_string8(&head, &session.last_version)
            session.net_lock.signal()
        case MSG_RESPONSE_GET_FILE:
            version, relative_file: StringBuilder
            defer { version.cleanup() relative_file.cleanup() }

            stream.read_string8(&head, &version)
            stream.read_string8(&head, &relative_file)
            file_size: i32;
            stream.read(&head, &file_size)

            // log("File recieved: ", version, " ", relative_file, " size: ", file_size)

            if file_size == 0 {
                session.bad_file = true
                log(" server is missing ", relative_file)
                session.net_lock.signal()
                return
            }

            new_ptr := Reallocate(file_size, session.get_file_data.ptr, session.get_file_data.len)
            Assert(new_ptr)

            session.get_file_data.ptr = new_ptr
            session.get_file_data.len = file_size;
            
            stream.read(&head, session.get_file_data.ptr, file_size)

            session.net_lock.signal()
        case: // dd nothing
    }
}

global public_key: char[815]; // 814+1, allocate extra byte for null terminator
#run {
    // Whenever we are dealing with slice.len we don't expect len to include null terminator.
    // We should therefore not start doing that here.
    public_key.len--

    file_size: i64
    file := FileOpen("public_key.pem", FILE_READ_ONLY, &file_size)
    defer  FileClose(file)
    Assert(public_key.len == file_size)

    FileRead(file, public_key.ptr, file_size)
    public_key.ptr[file_size] = '\0'
    // log("Inserted public key into installer, ", file_size)
}